1. 就是上层允许调用下层，而下层不能直接调用上层的api，这样做层次清晰，不会出现你中有我，我中有你的高度耦合的情况存

2. skynet核心功能是什么：它仍然是一个基于事件的高并发消息处理框架。事件主要来源于网络，定时器和信号通知等，当事件触发时，skynet将这些事件统一编码成消息结构，
     派发给感兴趣的服务处理；而服务在处理消息时，也可以主动向其他服务发送消息。因此他是事件来驱动的，如果没有前面说的那些事件，skynet就没法做任何事情。

3. skynet的核心数据结构是 skynet_context ，我对Erlang不熟悉，所以没法说出它对应于Erlang的什么结构；但它实际上也像操作系统中的进程的概念，在这里我们把它称之为服务，
    一个服务包含了下面几个东西：

服务句柄：和进程ID类似，用于唯一标识服务。
服务模块：模块以动态库的形式提供。在创建skynet_context的时候，必须指定模块的名字，skynet把模块加载进来，创建模块实例，实例向服务注册一个回调函数，用于处理服务的消息。
消息队列：每个服务都有一个消息队列，当队列中有消息时，会主动挂到全局链表。skynet启动了一定数量的工作线程，不断从全局链表取出消息队列，派发消息给服务的回调函数去处理

4. C+lua做到了golang费劲心力魔改编译器才做到的协程，类似async和await，执行序进出lua虚拟机的过程中上下文变量全靠环境自动维持，挺巧妙的


5 每个Lua服务可以保证，同一时刻，只有一个线程在执行Lua协程，所以我们完全不必担心线程同步的问题，当我们在编写Lua服务时，就把它当成一个单线程一样。
这段话的前提是不能在lua中修改全局变量，当其中一个协程1中修改了一个全局状态变量a，而另一个协程2又依赖a，当协程切换执行时，依赖a的那个协程2，在本身的上下文中感知不到a被改变了，
从而造成问题。而要在程序员脑袋中
时刻注意全局变量在切换到其它协程时是否被改变，造成的心智负担又很大。
所以如果一个Lua服务，当成一个单线程，是不合适的，多线程中该有的问题，多协程一样避免不了
===================================================================================
对，这是所有异步代码必然会碰到的问题，也不一定是全局变量，只要对另一个协程可见的变量都会有这个问题。这也是bug最容易产生的地方。
不过，这也没办法

6 Actor模型share nothing。所有的线程(或进程)通过消息传递的方式进行合作，这些线程(或进程)称为Actor。共享内存更适合单机多核的并发编程，而且共享带来的问题很多，编程也困难。
  随着多核时代和分布式系统的到来，共享模型已经不太适合并发编程，因此几十年前就已经出现的Actor模型又重新受到了人们的重视
 这就是Actor模式。每个线程都是一个Actor，这些Actor不共享任何内存，所有的数据都是通过消息传递的方式进行的

7. skynet 节点，通过 master ，认识网络中所有其它 skynet 节点。它们相互一一建立单向通讯通道。也就是说，如果一共有 100 个 skynet 节点，在它们启动完毕后，会建立起 1 万条通讯通道


8. 每个内部服务的实现，放在独立的动态库中。由动态库导出的三个接口 create init release 来创建出服务的实例。init 可以传递字符串参数来初始化实例。
   比如用 lua 实现的服务（这里叫 snlua ），可以在初始化时传递启动代码的 lua 文件名

9. 每个服务都是严格的被动的消息驱动的，以一个统一的 callback 函数的形式交给框架。框架从消息队列里取到消息，调度出接收的服务模块，找到 callback 函数入口，调用它。
   服务本身在没有被调度时，是不占用任何 CPU 的。框架做两个必要的保证。
   一、一个服务的 callback 函数永远不会被并发。
   二、一个服务向两一个服务发送的消息的次序是严格保证的

10 一个服务，默认不会执行任何逻辑，需要别人向它发出请求时，才会执行对应的逻辑（定时器也是通过消息队列，告诉指定服务，要执行定时事件），
   并在需要时返回结果给请求者。请求者往往也是其他服务。服务间的请求、响应和推送，并不是直接调用对方的api来执行，而是通过一个消息队列，
   也就是说，不论是请求、回应还是推送，都需要通过这个消息队列转发到另一个服务中。skynet的消息队列，分为两级，一个全局消息队列，他包含一个头尾指针，
   分别指向两个隶属于指定服务的次级消息队列。skynet中的每一个服务，都有一个唯一的、专属的次级消息队列

11 skynet一共有4种线程，monitor线程用于检测节点内的消息是否堵住，timer线程运行定时器，socket线程进行网络数据的收发，
   worker线程则负责对消息队列进行调度（worker线程的数量，可以通过配置表指定）。消息调度规则是，每条worker线程，每次从全局消息队列中pop出一个次级消息队列，
   并从次级消息队列中pop出一条消息，并找到该次级消息队列的所属服务，将消息传给该服务的callback函数，执行指定业务，当逻辑执行完毕时，
   再将次级消息队列push回全局消息队列中。因为每个服务只有一个次级消息队列，每当一条worker线程，从全局消息队列中pop出一个次级消息队列时，
   其他线程是拿不到同一个服务，并调用callback函数，因此不用担心一个服务同时在多条线程内消费不同的消息，一个服务执行，不存在并发，线程是安全的

12  我们所写的不同的业务逻辑，可以运行在不同的独立的沙盒环境中，他们之间是通过消息队列来进行交互的。worker、timer和socket线程里运行的模块，
    都有机会向特定的服务push消息，他们是消息的生产者，而worker线程内的模块，同时也是消息的消费者（确切的说，应该是那些服务)

13 注意：服务模块要将数据，通过socket发送给客户端时，并不是将数据写入消息队列，而是通过管道从worker线程，发送给socket线程，并交由socket转发。
   此外，设置定时器也不走消息队列，而是直接将在定时器模块，加入一个timer_node。其实这样也很好理解，因为timer和socket线程内运行的模块并不是这里的
   context，因此消息队列他们无法消费.

14 skynet_context管理模块
   我们创建一个新的服务，首先要先找到对应服务的module，在创建完module实例并完成初始化以后，还需要创建一个skynet_context上下文，
   并将module实例和module模块和这个context关联起来，最后放置于skynet_context list中，一个个独立的沙盒环境就这样被创建出来了

15  我们创建一个新的skynet_context时，会往slot列表中放，当一个消息送达一个context时，其callback函数就会被调用，
    callback函数一般在module的init函数里指定，调用callback函数时，会传入userdata（一般是instance指针），source（发送方的服务id），
    type（消息类型），msg和sz（数据及其大小），每个服务的callback处理各自的逻辑。这里其实可以将modules视为工厂，而skynet_context则是
    该工厂创建出来的实例，而这些实例，则是通过handle_storage来进行管理

16 消息与消息队列
   我们的创建的服务，需要通过消息来驱动，而一个服务要获取消息，是从消息队列里取的。skynet包含两级消息队列，一个global_mq，
   他包含一个head和tail指针，分别指向次级消息队列的头部和尾部，另外还有一个次级消息队列，这个一个单向链表。消息的派发机制是，工作线程，
   会从global_mq里pop一个次级消息队列来，然后从次级消息队列中，pop出一个消息，并传给context的callback函数，在完成驱动以后，
   再将次级消息队列push回global_mq中.

17 每条worker线程会被指定一个权重值，这个权重值决定一条线程一次消费多少条次级消息队列里的消息，当权重值< 0，worker线程一次消费一条消息
  （从次级消息队列中pop一个消息）；当权重==0的时候，worker线程一次消费完次级消息队列里所有的消息；当权重>0时，假设次级消息队列的长度为mq_length，
   将mq_length转成二进制数值以后，向右移动weight（权重值）位，结果N则是，该线程一次消费次级消息队列的消息数。在多条线程，同时运作时，每条worker线程
   都要从global_mq中pop一条次级消息队列出来，对global_mq进行pop和push操作的时候，会用自旋锁锁住临界区 

18 整个worker线程的消费流程是：
      a)  worker线程每次，从global_mq中弹出一个次级消息队列，如果次级消息队列为空，则该worker线程投入睡眠，timer线程每隔2.5毫秒
          会唤醒一条睡眠中的worker线程，并重新尝试从全局消息队列中pop一个次级消息队列出来，当次级消息队列不为空时，进入下一步
      b)  根据次级消息的handle，找出其所属的服务（一个skynet_context实例）指针，从次级消息队列中，pop出n条消息（受weight值影响），
          并且将其作为参数，传给skynet_context的cb函数，并调用它
      c)  当完成callback函数调用时，就从global_mq中再pop一个次级消息队列中，供下一次使用，
          并将本次使用的次级消息队列push回global_mq的尾部
      d) 返回第a步

19  socket_server这个结构，首先skynet的其他线程，向socket线程发送消息，是通过管道来进行的，也就是说，如果worker线程往sendctrl_fd写入数据，
    那么在socket线程，只需要对recvctrl_fd进行读取，就能收到worker线程发送过来的数据包，这么做的好处，则是使这一流程变得非常简单，而且保证线程安全。
    checkctrl则用来标记是否有其他线程向socket线程发送管道消息，如果有则被置为1。
    每次有epoll事件触发时，都会往epoll事件列表ev中写入，并返回事件的数量，每处理完一个事件，event_index就会增加一（每次epoll事件触发时，
    event_index都会被重置为0）

20 snlua 用来创建lua服务，一个lua服务对应一个lua虚拟机

21 Lua服务的入口脚本必须包含2点：1. require "skynet"，这样才能使用skynet.lua里的接口；2. 
   调用skyne.start函数

22 skynet.lua提供了很多api供Lua服务调用，第1行代码是local c = require "skynet.core"，
   skynet.core是由C编写的so库，so库里提供很多api供Lua层调用(lualib-src/lua-skynet.c)。
   require "skynet"过程中还做了其他事情放在下一篇介绍。

23  Lua服务入口的第二件事是调用skynet.start，重新设置消息回调函数（第3行，之前设置的
    launch_cb回调函数已经失效了）

24 void lua_setfield (lua_State *L, int index, const char *k);
   在lua脚本中表达的操作是：t[k] = v.  index指明了t在栈中的位置（说明：栈中首先要有表t），k代表了t的下标，
   v代表了赋予的值  （即：放置在栈顶的元素） 
   (注：调用这个函数之前，栈中应该有：表t 和 栈顶元素v)
   调用完成后，会将栈顶元素v弹出。


25 通常来说，C函数需要保留一些非局部的数据，也就是指那些超过他们作用范围的数据。C语言中我们使用全局变量或者
   static变量来满足这种需要。然而当你为Lua设计一个程序库的时候，全局变量和static变量不是一个好的方法。首先，不能将所有的Lua
   值保存到一个C变量中。第二，使用这种变量的库不能在多个Lua状态的情况下使用。
  一个替代的解决方案是将这些值保存到一个Lua全局变两种，这种方法解决了前面的两个问题。Lua全局变量可以存放任何类型的Lua值，
  并且每一个独立的状态都有他自己独立的全局变量集。然而，并不是在所有情况下，这种方法都是令人满意地解决方案，
  因为Lua代码可能会修改这些全局变量，危及C数据的完整性。为了避免这个问题，Lua提供了一个独立的被称为registry的表，
  C代码可以自由使用，但Lua代码不能访问他。
 
 假索引
   LUA_REGISTRYINDEX、LUA_ENVIRONINDEX、 LUA_GLOBALSINDEX是一个假索引（pseudo-indices），一个假索引除了他对应的值不在栈中之外，
   其他都类似于栈中的索引。 Lua API 中大部分接受索引作为参数的函数，其实可以理解为一张普通表格，你可以使用任何非nil的Lua值来访问她的元素

26 lua_getglobal(L, "background");//获取全局变量的background的值,并将其放入栈顶

27 luaL_openlibs(L); //把所有标准类库加载到指定的虚拟机

28 lua_pop(L,num)函数从栈顶开始移除。
   当num>0时从栈顶移除指定个数 。
   当num=0时栈不受影响
   当num=-1时栈中元素全部移除

29 lua_settop函数说明
   1. 该函数用于指定栈的高度，栈只能从栈顶压栈，不能从栈底添加数据。所以栈底的数据会保持不变。
   2. 当新的高度大于原来的高度时，会从栈顶压入数据，压入的数据不可用(因为是随机的)。
   3. 当新的高度小于原来的高度时，会从栈顶移除多余的元素。
   4. 当输入参数为负数时，表示从栈顶开始的索引（最栈顶元素为-1）。该函数会移除栈顶到该元素之间的所以元素。-1则无，-2 则移除-1 。
      -3则移除-1，-2。   以此类推。但是负数编号不能超出栈底的负数索引，超出会抛出异常。lua_pop函数及是使用了该特性。
	
30  lua_setglobal(L, name)，弹出栈顶的值，并设置为全局变量name的新值（name可以在Lua中未定义）

31  void lua_getfield (lua_State *L, int index, const char *k);
    把 t[k] 值压入堆栈，这里的 t 是指有效索引 index 指向的值。在 Lua 中，这个函数可能触发对应 "index" 事件的元方法



























































