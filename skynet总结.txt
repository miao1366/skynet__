1. 就是上层允许调用下层，而下层不能直接调用上层的api，这样做层次清晰，不会出现你中有我，我中有你的高度耦合的情况存

2. skynet核心功能是什么：它仍然是一个基于事件的高并发消息处理框架。事件主要来源于网络，定时器和信号通知等，当事件触发时，skynet将这些事件统一编码成消息结构，派发给感兴趣的服务处理；而服务在处理消息时，也可以主动向其他服务发送消息。因此他是事件来驱动的，如果没有前面说的那些事件，skynet就没法做任何事情。

3. skynet的核心数据结构是 skynet_context ，我对Erlang不熟悉，所以没法说出它对应于Erlang的什么结构；但它实际上也像操作系统中的进程的概念，在这里我们把它称之为服务，一个服务包含了下面几个东西：

服务句柄：和进程ID类似，用于唯一标识服务。
服务模块：模块以动态库的形式提供。在创建skynet_context的时候，必须指定模块的名字，skynet把模块加载进来，创建模块实例，实例向服务注册一个回调函数，用于处理服务的消息。
消息队列：每个服务都有一个消息队列，当队列中有消息时，会主动挂到全局链表。skynet启动了一定数量的工作线程，不断从全局链表取出消息队列，派发消息给服务的回调函数去处理

4. C+lua做到了golang费劲心力魔改编译器才做到的协程，类似async和await，执行序进出lua虚拟机的过程中上下文变量全靠环境自动维持，挺巧妙的


5 每个Lua服务可以保证，同一时刻，只有一个线程在执行Lua协程，所以我们完全不必担心线程同步的问题，当我们在编写Lua服务时，就把它当成一个单线程一样。
这段话的前提是不能在lua中修改全局变量，当其中一个协程1中修改了一个全局状态变量a，而另一个协程2又依赖a，当协程切换执行时，依赖a的那个协程2，在本身的上下文中感知不到a被改变了，从而造成问题。而要在程序员脑袋中时刻注意全局变量在切换到其它协程时是否被改变，造成的心智负担又很大。
所以如果一个Lua服务，当成一个单线程，是不合适的，多线程中该有的问题，多协程一样避免不了
===================================================================================
对，这是所有异步代码必然会碰到的问题，也不一定是全局变量，只要对另一个协程可见的变量都会有这个问题。这也是bug最容易产生的地方。
不过，这也没办法

6 
















































































